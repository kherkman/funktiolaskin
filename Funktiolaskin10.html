<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <title>Algebra Laskin (3D-graafilla Korjattu)</title>
    <!-- Ladataan tarvittavat kirjastot: Math.js, function-plot (2D) ja Three.js (3D) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.js"></script>
    <script src="https://unpkg.com/function-plot/dist/function-plot.js"></script>
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/" } }</script>
    
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 700px; margin: auto; padding: 20px; background-color: #f7f9fc; color: #333; }
        h2, h3, h4 { color: #2c3e50; border-bottom: 2px solid #e0e0e0; padding-bottom: 5px; }
        .input-container { display: flex; align-items: center; justify-content: center; margin-bottom: 20px; }
        .equation-side { width: 42%; padding: 10px; font-size: 1.2em; border: 1px solid #ccc; border-radius: 5px; text-align: center; }
        .equals-sign { font-size: 1.8em; font-weight: bold; margin: 0 15px; }
        .button-container { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; }
        button { background-color: #007bff; color: white; border: none; padding: 12px 15px; border-radius: 5px; font-size: 1.1em; cursor: pointer; transition: background-color 0.2s; }
        button:hover { filter: brightness(90%); }
        #start-button { grid-column: 1 / -1; }
        #undo-button { background-color: #6c757d; }
        #quadratic-solver-button { background-color: #28a745; }
        #reset-button { background-color: #dc3545; }
        .steps { border: 1px solid #ddd; background-color: #ffffff; padding: 15px; margin-top: 20px; min-height: 100px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .step { margin-bottom: 10px; font-family: 'Courier New', Courier, monospace; font-size: 1.4em; padding: 8px; border-bottom: 1px solid #f0f0f0; white-space: nowrap; overflow-x: auto; }
        .step:last-child { border-bottom: none; }
        #modification-area { margin-top: 25px; }
        #result-area, #graph-area { margin-top: 20px; }
        #modification-input { margin-top: 5px; padding: 10px; width: calc(100% - 22px); border: 1px solid #ccc; border-radius: 5px; font-size: 1.1em; }
        .info-box { background-color: #e9ecef; border: 1px solid #ced4da; padding: 15px; margin-top: 15px; border-radius: 5px; }
        .info-box code, .formula { background-color: #fff; padding: 3px 6px; border-radius: 4px; font-family: 'Courier New', monospace; }
        #quadratic-result { font-size: 1.2em; font-weight: bold; color: #155724; }
        .graph-container { border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #fff; min-height: 400px; }
        .graph-container canvas { display: block; width: 100% !important; height: auto !important; }
    </style>
</head>
<body>
    <h2>Algebra Laskin</h2>
    <div class="input-container"> <input type="text" id="left-side" class="equation-side" placeholder="x^2"> <span class="equals-sign">=</span> <input type="text" id="right-side" class="equation-side" placeholder="0"> </div>
    <div class="button-container"> <button id="start-button" onclick="startSolving()">Aloita ratkaisu</button> <button id="undo-button" onclick="undoLastStep()" style="display: none;">Peruuta</button> <button id="quadratic-solver-button" onclick="solveQuadratic()" style="display: none;">Ratkaise 2. asteen yhtälö</button> <button id="reset-button" onclick="resetCalculator()" style="display: none;">Aloita uusi</button> </div>
    <div id="modification-area" style="display: none;"> <h3>Vaiheet:</h3> <div id="steps" class="steps"></div> <div id="result-area"></div> <div id="graph-area"></div> <label for="modification-input" style="display: block; margin-top: 20px;">Tee muutos ja paina Enter:</label> <input type="text" id="modification-input" onkeyup="handleModificationInput(event)"> </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        let history = [];
        let animationFrameId = null; 
        const ui = {
            steps: document.getElementById('steps'), modInput: document.getElementById('modification-input'), result: document.getElementById('result-area'), graphs: document.getElementById('graph-area'), modArea: document.getElementById('modification-area'), startButton: document.getElementById('start-button'), undoButton: document.getElementById('undo-button'), solverButton: document.getElementById('quadratic-solver-button'), resetButton: document.getElementById('reset-button')
        };
        const OPERATOR_FUNCTIONS = { '+': 'add', '-': 'subtract', '*': 'multiply', '/': 'divide', '^': 'pow' };

        function solveQuadratic() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId); 
            clearAllResults();
            const currentStep = history[history.length - 1];
            if (currentStep.right.toString() !== '0') { alert("Varmista, että yhtälö on muodossa '... = 0'."); return; }
            try {
                const poly = currentStep.left;
                const { a, b, c } = getCoefficients(poly, 'x');

                if (!Number.isFinite(a) || !Number.isFinite(b) || !Number.isFinite(c)) {
                    alert("Yhtälöä ei voitu muuttaa toisen asteen polynomiksi. Varmista, että se on muotoa ax²+bx+c ja yritä uudelleen.");
                    return;
                }
                
                if (a === 0) { alert("Tämä ei ole toisen asteen yhtälö (a=0)."); return; }

                const discriminant = b * b - 4 * a * c;
                const x1 = math.divide(math.add(-b, math.sqrt(discriminant)), 2 * a);
                const x2 = math.divide(math.subtract(-b, math.sqrt(discriminant)), 2 * a);
                
                displayResults(poly, {a, b, c}, discriminant, x1, x2);
                setupGraphContainers(discriminant < 0);
                draw2DGraphs(poly.toString(), discriminant >= 0 ? [x1, x2] : [], discriminant < 0 ? [x1, x2] : []);
                draw3DGraph_ThreeJS({a, b, c});

            } catch (e) { alert("Tunnistusvirhe: " + e.message); console.error(e); }
        }

        function displayResults(poly, coeffs, D, x1, x2) {
            const {a, b, c} = coeffs;
            let resultHTML = `<div class="info-box"><h4>Toisen asteen yhtälön ratkaisu</h4>` +
                             `<p>Yhtälö: <code>${poly.toString()} = 0</code> | Kertoimet: <code>a=${a}, b=${b}, c=${c}</code></p>` +
                             `<hr><p><b>Diskriminantti D = b² - 4ac:</b> <span class="formula">(${b})² - 4*(${a})*(${c}) = ${D}</span></p><hr>`;
            if (D < 0) {
                resultHTML += `<p id="quadratic-result">Yhtälöllä on kaksi kompleksista liittolukuratkaisua:<br><b>x₁ = ${x1.toString()}</b><br><b>x₂ = ${x2.toString()}</b></p>`;
            } else {
                resultHTML += `<p id="quadratic-result">Yhtälön reaaliset ratkaisut:<br><b>x₁ = ${math.format(x1.re, 14)}</b><br><b>x₂ = ${math.format(x2.re, 14)}</b></p>`;
            }
            ui.result.innerHTML = resultHTML + `</div>`;
        }
        function setupGraphContainers(hasComplexRoots) {
            let html = `<div class="info-box"><h4>Funktion kuvaaja (reaalitaso)</h4><div id="plot-real" class="graph-container"></div></div>`;
            if (hasComplexRoots) {
                html += `<div class="info-box"><h4>Kompleksisten juurien sijainti (Argandin diagrammi)</h4><div id="plot-argand" class="graph-container"></div></div>`;
            }
            // *** SELITETEKSTI KORJATTU TÄSSÄ ***
            html += `<div class="info-box"><h4>3D-visualisointi kompleksitasossa</h4><p>Akselit: X=Re(z), Z=Im(z), Y=Re(f(z)).</p><div id="plot-3d" class="graph-container"></div></div>`;
            ui.graphs.innerHTML = html;
        }
        function draw2DGraphs(fn, realRoots, complexRoots) {
            setTimeout(() => {
                const realPlotContainer = document.getElementById('plot-real');
                if (!realPlotContainer) return;
                functionPlot({ target: '#plot-real', width: realPlotContainer.clientWidth, height: 350, grid: true, data: [{ fn }, { points: realRoots.map(r => [r.re, 0]), fnType: 'points', graphType: 'scatter' }] });
                if (complexRoots.length > 0) {
                    const argandPlotContainer = document.getElementById('plot-argand');
                    if (!argandPlotContainer) return;
                    functionPlot({ target: '#plot-argand', width: argandPlotContainer.clientWidth, height: 300, grid: true, xAxis: { label: 'Reaaliosa' }, yAxis: { label: 'Imaginaariosa' }, data: [{ points: complexRoots.map(r => [r.re, r.im]), fnType: 'points', graphType: 'scatter' }] });
                }
            }, 0);
        }

        function draw3DGraph_ThreeJS(coeffs) {
            setTimeout(() => {
                const container = document.getElementById('plot-3d');
                if (!container || container.clientWidth === 0) { return; }

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, container.clientWidth / 400, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, 400);
                container.innerHTML = '';
                container.appendChild(renderer.domElement);
                
                const controls = new OrbitControls(camera, renderer.domElement);
                scene.add(new THREE.AmbientLight(0xffffff, 0.7));
                const light = new THREE.DirectionalLight(0xffffff, 0.8);
                light.position.set(10, 20, 5);
                scene.add(light);

                const range = 5; 
                const segments = 80;
                const geometry = new THREE.PlaneGeometry(range * 2, range * 2, segments, segments);
                geometry.rotateX(-Math.PI / 2);

                const positions = geometry.attributes.position;
                const yClamp = 15;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i), z = positions.getZ(i);
                    const z_input = math.complex(x, z);
                    const z_output = math.add(math.add(math.multiply(coeffs.a, math.pow(z_input, 2)), math.multiply(coeffs.b, z_input)), coeffs.c);
                    
                    // *** KORJATTU LASKENTA TÄSSÄ ***
                    let y = z_output.re; // Käytetään reaaliosaa, ei itseisarvoa
                    
                    y = !Number.isFinite(y) ? 0 : Math.max(-yClamp, Math.min(y, yClamp)); 
                    positions.setY(i, y);
                }
                positions.needsUpdate = true;
                geometry.computeVertexNormals();
                scene.add(new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x2196F3, side: THREE.DoubleSide })));
                
                scene.add(new THREE.GridHelper(range * 2, range * 2));
                camera.position.set(range * 1.2, range * 1.5, range * 1.2);
                controls.target.set(0, 0, 0);
                controls.update();

                function animate() {
                    animationFrameId = requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();
            }, 0);
        }
        
        // Globaalit apufunktiot
        function clearAllResults() { ui.result.innerHTML = ''; ui.graphs.innerHTML = ''; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }
        window.getCoefficients = (node, v) => { const s = {[v]:0}; return {c:node.evaluate(s), b:math.derivative(node,v).evaluate(s), a:math.derivative(math.derivative(node,v),v).evaluate(s)/2}; };
        window.resetCalculator = () => { clearAllResults(); history = []; ui.steps.innerHTML = ''; document.getElementById('left-side').value = ''; document.getElementById('right-side').value = ''; ui.modArea.style.display = 'none'; ui.startButton.style.display = 'block'; ui.undoButton.style.display = 'none'; ui.solverButton.style.display = 'none'; ui.resetButton.style.display = 'none'; };
        window.startSolving = () => { clearAllResults(); const l = document.getElementById('left-side').value, r = document.getElementById('right-side').value; if (!l && !r) return; history = []; try { history.push({left: math.simplify(math.parse(l||'0')), right: math.simplify(math.parse(r||'0'))}); } catch (e) { alert("Virheellinen syöte."); return; } redrawSteps(); ui.modArea.style.display = 'block'; ui.startButton.style.display = 'none'; ui.undoButton.style.display = 'block'; ui.solverButton.style.display = 'block'; ui.resetButton.style.display = 'block'; ui.modInput.value = ''; ui.modInput.focus(); };
        window.undoLastStep = () => { clearAllResults(); if (history.length > 1) { history.pop(); redrawSteps(); } };
        window.redrawSteps = () => { ui.steps.innerHTML = ''; history.forEach(s => { const el = document.createElement('div'); el.className = 'step'; el.textContent = `${s.left.toString()} = ${s.right.toString()}`; ui.steps.appendChild(el); }); ui.steps.scrollTop = ui.steps.scrollHeight; };
        window.handleModificationInput = (event) => { if (event.key === 'Enter') { clearAllResults(); applyModification(); } }
        window.applyModification = () => { const modStr = ui.modInput.value.trim(); if (!modStr) return; const current = history[history.length - 1]; try { const opMatch = modStr.match(/^([*\/+\-^])\s*(.*)$/); const logMatch = modStr.match(/^log(?:\((.*)\))?$/i); let newLeft, newRight; if (opMatch) { const [_, op, val] = opMatch; if (!val) throw new Error("Arvo puuttuu."); newLeft = new math.OperatorNode(op, OPERATOR_FUNCTIONS[op], [current.left, math.parse(val)]); newRight = new math.OperatorNode(op, OPERATOR_FUNCTIONS[op], [current.right, math.parse(val)]); } else if (logMatch) { const base = logMatch[1] ? [math.parse(logMatch[1])] : []; newLeft = new math.FunctionNode('log', [current.left, ...base]); newRight = new math.FunctionNode('log', [current.right, ...base]); } else { throw new Error("Tuntematon operaatio."); } history.push({ left: math.simplify(newLeft), right: math.simplify(newRight) }); redrawSteps(); ui.modInput.value = ''; ui.modInput.focus(); } catch (e) { alert("Virhe: " + e.message); } };
        window.solveQuadratic = solveQuadratic;
    </script>
</body>
</html>